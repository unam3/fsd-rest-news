drop table if exists authors cascade;
drop table if exists users cascade;
drop table if exists categories cascade;
drop table if exists tags cascade;
drop table if exists articles cascade;
drop table if exists articles_tags cascade;
drop table if exists articles_comments cascade;

begin;


create table users (
    user_id         integer generated always as identity,
    name            varchar(80) not null,
    surname         varchar(80) not null,
    avatar          text,
    creation_date   timestamp DEFAULT current_timestamp,
    is_admin        boolean not null,

    primary key (user_id)
);

INSERT INTO users (name, surname, avatar, is_admin) VALUES
    ('Scott', 'Adams', 'http://pluh/meh.jpg', true),
    ('Stephen', 'Diehl', 'http://pluh/monad.jpg', false),
    ('Sean', ' Carroll', 'https://preposterousuniverse.com/quant.jpg', false),
    ('Phil', 'Well', 'https://daaaa.mn/it.jpg', false),
    ('Douglas', 'Crockford', 'https://daaaa.mn/it.jpg', false),
    ('Snoyberg', 'FPComplete', 'http://pluh/kek.jpg', false);


create table authors (
    author_id       integer generated always as identity primary key,
    user_id         integer references users unique,
    description     text not null
);

INSERT INTO authors (user_id, description) VALUES
    (1, 'Hey you'),
    (2, 'What I wish I knew'),
    (3, 'Quantum relativity itself'),
    (4, 'Well duh');

-- how to create possible parental relations between rows?
create table categories (
    category_id     integer generated always as identity primary key,
    name            varchar(80) not null,
    parent_id       integer references categories
);

INSERT INTO categories (name, parent_id) VALUES
    ('cat1', null),
    ('cat2', 1),
    ('cat3', 1),
    ('cat4', 2),
    ('cat5', 3),
    ('cat6', 5),
    ('cat7', 4);

create table tags (
    tag_id          integer generated always as identity primary key,
    tag_name        varchar(80) not null
);

INSERT INTO tags (tag_name) VALUES
    ('tag'),
    ('tag1'),
    ('tag2');

create table articles (
    article_id          integer generated always as identity,
    article_title       varchar(80) not null,
    creation_date       timestamp DEFAULT current_timestamp,
    author              integer references authors (author_id),
    category_id         integer references categories,
    article_content     text not null,
    is_published        boolean not null,
    primary key (article_id)

    --main_photo          photos not null, -- !
    --additional_photos   photos not null -- !
);

--create table articles_drafts (
--    article_id         integer references articles (article_id)
--);

--create table articles_published (
--    article_id         integer references articles (article_id)
--);

INSERT INTO articles (author, category_id, article_title, article_content, is_published) VALUES
    (1, 1, 'Loserthink', 'If you’re interested in expanding how you think things through, check out Loserthink.', true),
    (2, 2, 'How To Solve It', 'Polya', true),
    --(1, 2, E'You\'ve never imagine what was…', 'And today topic is children education.', false),
    --(4, 2, 'You''ve never imagine what was…', 'And today topic is children education.', false),
    (4, 2, 'Oh my gooood.', 'No one ever really dies.', false),
    (3, 1, 'Something Deeply Hidden', 'New book out!', false),
    (2, 2, 'What I Wish I Knew When Learning Haskell', 'English.', false),
    (2, 2, 'Пыщ', 'Еей!', false),
    (3, 1, 'The Big Picture', 'New book again!', false);


create table articles_tags (
    tag_id          integer references tags (tag_id),
    article_id      integer references articles (article_id),
    primary key (tag_id, article_id)
);

INSERT INTO articles_tags (tag_id, article_id) VALUES
    (1, 1),
    (2, 1),
    (3, 1),
    (2, 2),
    (3, 3);

create table articles_comments (
    comment_id      integer generated always as identity,
    author          integer references authors (author_id),
    article_id      integer references articles (article_id) not null,
    comment_text    text not null
);

INSERT INTO articles_comments (article_id, author, comment_text) VALUES
    (1, 2, 'kek'),
    (1, 3, 'pluh'),
    (2, 4, 'meh');

commit;

select * from users;
select * from categories;
select * from articles;
select * from articles_tags;
select * from articles_comments;

CREATE OR REPLACE FUNCTION public.get_article(art_id integer)
       RETURNS json
       LANGUAGE sql
    AS $function$
        select row_to_json(as_row) from (
            --is_published        boolean not null,
            select
                a.article_id,
                a.article_title,
                a.article_content,
                a.creation_date,
                categories_hierarchy.json_agg as categories,
                aauthor as author,
                atags.json_agg as tags
            from
                articles a,
                (select * from authors where author_id = (
                        select author from articles where article_id = art_id
                    )
                ) as aauthor,
                (select json_agg(tags) from (
                        select tags.*
                        from tags
                        inner join articles_tags
                        on tags.tag_id = articles_tags.tag_id
                        where article_id = art_id
                    ) as tags
                ) as atags,
                (
                    WITH RECURSIVE categories_recursive(category_id, name, parent_id) AS (
                        SELECT category_id, name, parent_id
                        FROM categories
                        WHERE category_id = (select category_id from articles as a where a.article_id = art_id)
                        UNION ALL
                        SELECT categories.category_id, categories.name, categories.parent_id
                        FROM categories_recursive, categories
                        WHERE categories_recursive.parent_id = categories.category_id
                    )
                    SELECT json_agg(row_to_json(categories_recursive.*)) FROM categories_recursive
                ) as categories_hierarchy where a.article_id = art_id
        ) as as_row;
    $function$;

SET plpgsql.extra_warnings TO 'all';
SET plpgsql.extra_errors TO 'all';

CREATE OR REPLACE FUNCTION public.check_assignment(
    author integer,
    category_id integer,
    article_title varchar,
    article_content text,
    tags int[]
)
       RETURNS json
       LANGUAGE plpgsql
    AS $function$
        declare
            created_draft articles%rowtype;
            --tag_ids json;
            assigned_tags json;
        begin
            insert into articles
            (author, category_id, article_content, article_title, is_published) values
            (author, category_id, article_content, article_title, false)
            returning * into created_draft;

            insert into articles_tags
            (tag_id, article_id)
            (select unnest(tags), created_draft.article_id);
            -- returning works only for single row
            -- aggregate functions are not allowed in RETURNING
            --returning json_agg(tag_id) into tag_ids;
            
            return json_build_object( 
                'article_id', created_draft.article_id,
                'author', created_draft.author,
                'category_id', created_draft.category_id,
                'article_title', created_draft.article_title,
                'article_content', created_draft.article_content,
                'is_published', created_draft.is_published,
                'tags', (
                    select json_agg(tags.*)
                    from tags
                    inner join articles_tags
                    on tags.tag_id = articles_tags.tag_id
                    where article_id = created_draft.article_id
                )
            );
        end;
    $function$;
