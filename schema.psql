drop table if exists authors cascade;
drop table if exists users cascade;
drop table if exists categories cascade;
drop table if exists tags cascade;
drop table if exists articles cascade;
drop table if exists articles_tags cascade;
drop table if exists articles_comments cascade;

begin;

create table users (
    user_id         integer generated always as identity,
    username        text not null unique,
    password        text not null,
    name            varchar(80) not null,
    surname         varchar(80) not null,
    avatar          text,
    creation_date   timestamp DEFAULT current_timestamp,
    is_admin        boolean not null,

    primary key (user_id)
);

INSERT INTO users (username, password, name, surname, avatar, is_admin) VALUES
    ('username', crypt('12345', gen_salt('bf', 8)), 'Scott', 'Adams', 'http://pluh/meh.jpg', true),
    ('username1', crypt('12345', gen_salt('bf', 8)), 'Stephen', 'Diehl', 'http://pluh/monad.jpg', false),
    ('username2', crypt('12345', gen_salt('bf', 8)), 'Sean', ' Carroll', 'https://preposterousuniverse.com/quant.jpg', false),
    ('username3', crypt('12345', gen_salt('bf', 8)), 'Phil', 'Well', 'https://daaaa.mn/it.jpg', false),
    ('username4', crypt('12345', gen_salt('bf', 8)), 'Douglas', 'Crockford', 'https://daaaa.mn/it.jpg', false),
    ('username5', crypt('12345', gen_salt('bf', 8)), 'Snoyberg', 'FPComplete', 'http://pluh/kek.jpg', false);



create table authors (
    author_id       integer generated always as identity primary key,
    -- user_id         integer references users on delete cascade unique,
    user_id         integer references users unique,
    description     text not null
);

INSERT INTO authors (user_id, description) VALUES
    (1, 'Hey you'),
    (2, 'What I wish I knew'),
    (3, 'Quantum relativity itself'),
    (4, 'Well duh');

-- how to create possible parental relations between rows?
create table categories (
    category_id     integer generated always as identity primary key,
    name            varchar(80) not null,
    parent_id       integer references categories
);

INSERT INTO categories (name, parent_id) VALUES
    ('cat1', null),
    ('cat2', 1),
    ('cat3', 1),
    ('cat4', 2),
    ('cat5', 3),
    ('cat6', 5),
    ('cat7', 4);

create table tags (
    tag_id          integer generated always as identity primary key,
    tag_name        varchar(80) not null unique
);

INSERT INTO tags (tag_name) VALUES
    ('tag1'),
    ('tag2'),
    ('tag3');

create table articles (
    article_id          integer generated always as identity,
    article_title       varchar(80) not null,
    creation_date       timestamp DEFAULT current_timestamp,
    author              integer references authors (author_id),
    category_id         integer references categories,
    article_content     text not null,
    is_published        boolean not null,
    main_photo          text,
    additional_photos   text[] not null default array[]::text[],
    primary key (article_id)
);

--create table articles_drafts (
--    article_id         integer references articles (article_id)
--);

--create table articles_published (
--    article_id         integer references articles (article_id)
--);

INSERT INTO articles (
        author,
        category_id,
        article_title,
        article_content,
        is_published,
        main_photo,
        additional_photos
    ) VALUES
    (1, 1, 'Loserthink', 'If you’re interested in expanding how you think things through, check out Loserthink.', true, 'asdjf',  array[]::text[]),
    (2, 2, 'How To Solve It', 'Polya', true, '', array['one link']::text[]),
    --(1, 2, E'You\'ve never imagine what was…', 'And today topic is children education.', false),
    --(4, 2, 'You''ve never imagine what was…', 'And today topic is children education.', false),
    (4, 2, 'Oh my gooood.', 'No one ever really dies.', false, '', array['two', 'links']::text[]),
    (3, 1, 'Something Deeply Hidden', 'New book out!', false, 'main ph', array['two', 'links']::text[]),
    (2, 2, 'What I Wish I Knew When Learning Haskell', 'English.', false, '', array['three', 'eee', 'links']::text[]),
    (2, 2, 'Пыщ', 'Еей!', false, '', array['f', 'o', 'u', 'r']::text[]),
    (2, 2, 'Disparaged', 'So', false, 'main', array['thr', 'e', 'e']::text[]),
    (3, 1, 'The Big Picture', 'New book again!', false, 'main', array['f', 'o', 'u', 'r']::text[]);

update articles
set creation_date = timestamp '2020-12-09 20:20:20.666628'
where article_id = 1;

update articles
set creation_date = timestamp '2020-12-09 18:18:18.666628'
where article_id = 2;

update articles
set creation_date = timestamp '2020-12-09 11:11:11.666628'
where article_id = 3;

update articles
set creation_date = timestamp '2020-12-09 19:19:19.666628'
where article_id = 4;

update articles
set creation_date = timestamp '2020-12-09 12:12:12.666628'
where article_id = 5;

update articles
set creation_date = timestamp '2020-12-09 15:15:15.666628'
where article_id = 6;

update articles
set creation_date = timestamp '2020-12-09 14:14:14.666628'
where article_id = 7;

update articles
set creation_date = timestamp '2020-12-09 13:13:13.666628'
where article_id = 8;


create table articles_tags (
    tag_id          integer references tags (tag_id),
    article_id      integer references articles (article_id) on delete cascade,
    primary key (tag_id, article_id)
);

INSERT INTO articles_tags (tag_id, article_id) VALUES
    (1, 1),
    (2, 1),
    (3, 1),
    (2, 2),
    (3, 3);

create table articles_comments (
    comment_id      integer generated always as identity,
    user_id         integer references users (user_id),
    article_id      integer references articles (article_id) not null,
    comment_text    text not null
);

INSERT INTO articles_comments (article_id, user_id, comment_text) VALUES
    (1, 2, 'kek'),
    (1, 3, 'pluh'),
    (2, 4, 'meh');

commit;

CREATE OR REPLACE FUNCTION public.get_article(art_id integer)
       RETURNS json
       LANGUAGE sql
    AS $function$
        with author as (
            select *
            from authors
            where author_id = (
                select author
                from articles
                where article_id = art_id
            )
        ), atags as (
            select json_agg(tags) from (
                    select tags.*
                    from tags
                    inner join articles_tags
                    on tags.tag_id = articles_tags.tag_id
                    where article_id = art_id
                ) as tags
        ),
        categories_hierarchy as (
            WITH RECURSIVE categories_recursive(category_id, name, parent_id) AS (
                SELECT category_id, name, parent_id
                FROM categories
                WHERE category_id = (select category_id from articles as a where a.article_id = art_id)
                UNION ALL
                SELECT categories.category_id, categories.name, categories.parent_id
                FROM categories_recursive, categories
                WHERE categories_recursive.parent_id = categories.category_id
            )
            SELECT json_agg(row_to_json(categories_recursive.*)) FROM categories_recursive
        )
        select row_to_json(as_row) from (
            --is_published        boolean not null,
            select
                a.article_id,
                a.article_title,
                a.article_content,
                a.creation_date,
                categories_hierarchy.json_agg as categories,
                uuser as user,
                atags.json_agg as tags,
                a.main_photo,
                a.additional_photos
            from
                author,
                categories_hierarchy,
                atags,
                articles a,
                (   select
                        author.user_id,
                        name,
                        surname,
                        avatar,
                        creation_date
                    from users,
                        author
                    where users.user_id = author.user_id
                ) as uuser
        ) as as_row;
    $function$;

SET plpgsql.extra_warnings TO 'all';
SET plpgsql.extra_errors TO 'all';

CREATE OR REPLACE FUNCTION public.create_article_draft(
    author integer,
    category_id integer,
    article_title varchar,
    article_content text,
    tags int[],
    main_photo text,
    additional_photos text[]
)
       RETURNS json
       LANGUAGE plpgsql
    AS $function$
        declare
            created_draft articles%rowtype;
            assigned_tags json;
        begin
            insert into articles
            (author, category_id, article_content, article_title, is_published, main_photo, additional_photos) values
            (author, category_id, article_content, article_title, false, main_photo, additional_photos)
            returning * into created_draft;

            insert into articles_tags
            (tag_id, article_id)
            (select unnest(tags), created_draft.article_id);
            
            return json_build_object( 
                'article_id', created_draft.article_id,
                'author', created_draft.author,
                'category_id', created_draft.category_id,
                'article_title', created_draft.article_title,
                'article_content', created_draft.article_content,
                'is_published', created_draft.is_published,
                'tags', (
                    select json_agg(tags.*)
                    from tags
                    inner join articles_tags
                    on tags.tag_id = articles_tags.tag_id
                    where article_id = created_draft.article_id
                ),
                'main_photo',  created_draft.main_photo,
                'additional_photos',  created_draft.additional_photos
            );
        end;
    $function$;
